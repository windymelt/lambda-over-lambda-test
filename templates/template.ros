#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#


;;; ここに本来のrosファイルが挿入される
;;; shebangだけ削除しておく
{{body|safe}}

(progn ;;init forms
  (declaim (optimize (speed 0) (space 0) (debug 3) (safety 3)))
  (ros:ensure-asdf)
  (setf *features* (remove :ipv6 *features*)) ;; ccl
  #+quicklisp (ql:quickload '(:dexador :uiop :cl-ppcre :jsown :cl+ssl) :silent nil)
  )

(defpackage :ros.script.bootstrap.3758360166
  (:use :cl))
(in-package :ros.script.bootstrap.3758360166)

(defvar *handler*)
(defvar *lambda-task-root*)
(defvar *aws-lambda-runtime-api*)

(defun load-envvar ()
  "Loads environment variables to work lambda script correctly."
  (setf *handler*
        (uiop:getenv "_HANDLER"))
  (setf *lambda-task-root*
        (uiop:getenv "LAMBDA_TASK_ROOT"))
  (setf *aws-lambda-runtime-api*
        (uiop:getenv "AWS_LAMBDA_RUNTIME_API")))

(defun set-json-settings ()
  (setf jsown::*parsed-true-value* t)
  (setf jsown::*parsed-false-value* :f)
  (setf jsown::*parsed-null-value* :null)
  (setf jsown::*parsed-empty-list-value* nil))

(defun main-loop (handler)
  "Main loop processes lambda requests. Specify function designator with HANDLER."
  (declare (ignorable handler))
  (let ((next-endpoint
          (format nil "http://~A/2018-06-01/runtime/invocation/next" *aws-lambda-runtime-api*)))
    (loop for (body status headers . nil) = (progn (multiple-value-list (dex:get next-endpoint :keep-alive t :verbose t)))
          as request-id = (gethash "lambda-runtime-aws-request-id" headers)
          as response = (handler-case (funcall (find-symbol "ORIGINAL-MAIN" "{{ros-package}}") handler (jsown:parse body))
                          (error (c) `(:obj ("error" . ,(format nil "~A" c)))))
          as response-endpoint = (format nil "http://~A/2018-06-01/runtime/invocation/~A/response" *aws-lambda-runtime-api* request-id)
          as error-endpoint = (format nil "http://~A/2018-06-01/runtime/invocation/~A/error" *aws-lambda-runtime-api* request-id)
;; TODO: エラーハンドリングして処理を継続できるようにする，エラーは無視する
          do (dex:post response-endpoint :content (jsown:to-json response) :keep-alive t :verbose t))))

;; lambda entrypoint
(defun main ()
  (load-envvar)
  (set-json-settings)
  (uiop:chdir *lambda-task-root*)
;  (cl+ssl:reload)
  (setf *standard-output* *error-output*)
  (main-loop *handler*))
;;; vim: set ft=lisp lisp:
